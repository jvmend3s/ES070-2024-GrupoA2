/* ***************************************************************** */
/* File name:        pid.c                                           */
/* File description: This file has a couple of useful functions to   */
/*                   control the implemented PID controller          */
/* Author name:      julioalvesMS, IagoAF, rBacurau                  */
/* Creation date:    21jun2018                                       */
/* Revision date:    20mai2024                                       */
/* ***************************************************************** */

//CLASSE PID USADA PARA CONTROLE DA RODA ESQUERDA
#include <pid_motors.h>
#include "main.h"

// Struct used to store the PID configuration parameters
pid_data_type xPidConfig[2];
// Counter used to control the integration error window
unsigned short usIntegratorCount[2] = {0};
// Buffer used to store the errors to generate the integral error
float fIntegratorBuffer_left[INTEGRATOR_MAX_SIZE] = {0};
float fIntegratorBuffer_right[INTEGRATOR_MAX_SIZE] = {0};

float teste;

/* ************************************************ */
/* Method name:        vPidInit                     */
/* Method description: Initialize the PID controller*/
/* Input params:       n/a                          */
/* Output params:      n/a                          */
/* ************************************************ */
void vPidInit(float fKp, float fKi, float fKd, unsigned short usIntSizeMs, float fOutputSaturation, char motor)
{
	xPidConfig[motor].fKp = fKp;
	xPidConfig[motor].fKd = fKd;
	xPidConfig[motor].fKi = fKi;
	xPidConfig[motor].fError_previous = 0;
	xPidConfig[motor].fError_sum = 0.0;

	// Saturates Integrator size (up to 10 s)
	if((usIntSizeMs/UPDATE_RATE_MS)> INTEGRATOR_MAX_SIZE)
	  usIntSizeMs = INTEGRATOR_MAX_SIZE * UPDATE_RATE_MS;

	xPidConfig[motor].usIntegratorSize = usIntSizeMs/UPDATE_RATE_MS;

	xPidConfig[motor].fOutputSaturation = fOutputSaturation;
}

/* ************************************************** */
/* Method name:        fPidUpdateData                 */
/* Method description: Update the control output      */
/*                     using the reference and sensor */
/*                     value                          */
/* Input params:       fSensorValue: Value read from  */
/*                     the sensor                     */
/*                     fReferenceValue: Value used as */
/*                     control reference              */
/* Output params:      float: New Control effort      */
/* ************************************************** */
float fPidUpdateData(float fSensorValue, float fSetValue, char motor)
{
	float fError, fDifference, fOut;

	// Proportional error
	fError = fSetValue - fSensorValue;

	//Ingtegral error
	if (motor) { //right
		xPidConfig[motor].fError_sum = xPidConfig[motor].fError_sum - fIntegratorBuffer_right[usIntegratorCount[motor]] + fError;
		fIntegratorBuffer_right[usIntegratorCount[motor]] = fError;
	}
	else { //left
		xPidConfig[motor].fError_sum = xPidConfig[motor].fError_sum - fIntegratorBuffer_left[usIntegratorCount[motor]] + fError;
		fIntegratorBuffer_left[usIntegratorCount[motor]] = fError;
	}

	if(++usIntegratorCount[motor] >= xPidConfig[motor].usIntegratorSize)
		usIntegratorCount[motor] = 0;

	// Differential error
	fDifference = (fError - xPidConfig[motor].fError_previous);

	fOut = xPidConfig[motor].fKp * fError
		 + xPidConfig[motor].fKi * xPidConfig[motor].fError_sum * UPDATE_RATE
		 + xPidConfig[motor].fKd * fDifference / UPDATE_RATE;

	xPidConfig[motor].fError_previous = fError;

    // Output Saturation
	if(fOut > xPidConfig[motor].fOutputSaturation)
		fOut = xPidConfig[motor].fOutputSaturation;
	else
		if (fOut < 0)
			fOut = 0;

	return fOut;
}
